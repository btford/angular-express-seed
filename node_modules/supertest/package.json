{
  "name": "supertest",
  "version": "0.7.1",
  "description": "Super-agent driven library for testing HTTP servers",
  "main": "index.js",
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "superagent": "0.15.1",
    "methods": "0.0.1"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "express": "3.1.0"
  },
  "keywords": [
    "superagent",
    "request",
    "tdd",
    "bdd",
    "http",
    "test",
    "testing"
  ],
  "author": {
    "name": "TJ Holowaychuk"
  },
  "license": "MIT",
  "readme": "# SuperTest\n\n  HTTP assertions made easy via [super-agent](http://github.com/visionmedia/superagent).\n\n## About\n\n  The motivation with this module is to provide a high-level abstraction for testing\n  HTTP, while still allowing you to drop down to the lower-level API provided by super-agent.\n\n## Example\n\n  You may pass an `http.Server`, or a `Function` to `request()` - if the server is not\n  already listening for connections then it is bound to an ephemeral port for you so\n  there is no need to keep track of ports.\n\n  SuperTest works with any test framework, here is an example without using any\n  test framework at all:\n\n```js\nvar request = require('supertest')\n  , express = require('express');\n\nvar app = express();\n\napp.get('/user', function(req, res){\n  res.send(201, { name: 'tobi' });\n});\n\nrequest(app)\n  .get('/user')\n  .expect('Content-Type', /json/)\n  .expect('Content-Length', '20')\n  .expect(201)\n  .end(function(err, res){\n    if (err) throw err;\n  });\n```\n\n  Here's an example with mocha, note how you can pass `done` straight to any of the `.expect()` calls:\n\n```js\ndescribe('GET /users', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200, done);\n  })\n})\n```\n\n  If you are using the `.end()` method `.expect()` assertions that fail will\n  not throw - they will return the assertion as an error to the `.end()` callback. In\n  order to fail the test case, you will need to rethrow or pass `err` to `done()`, as follows:\n\n```js\ndescribe('GET /users', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect(200)\n      .end(function(err, res){\n        if (err) return done(err);\n        done()\n      });\n  })\n})\n```\n\n  Anything you can do with superagent, you can do with supertest - for example multipart file uploads!\n\n```js\nrequest(app)\n.post('/')\n.attach('avatar', 'test/fixtures/homeboy.jpg')\n...\n```\n\n  Passing the app or url each time is not necessary, if you're testing\n  the same host you may simply re-assign the request variable with the\n  initialization app or url, a new `Test` is created per `request.VERB()` call.\n\n```js\nrequest = request('http://localhost:5555');\n\nrequest.get('/').expect(200, function(err){\n  console.log(err);\n});\n\nrequest.get('/').expect('heya', function(err){\n  console.log(err);\n});\n```\n\n## API\n\n  You may use any [super-agent](http://github.com/visionmedia/superagent) methods,\n  including `.write()`, `.pipe()` etc and perform assertions in the `.end()` callback\n  for lower-level needs.\n\n### .expect(status[, fn])\n\n  Assert response `status` code.\n\n### .expect(status, body[, fn])\n\n  Assert response `status` code and `body`.\n\n### .expect(body[, fn])\n\n  Assert response `body` text with a string, regular expression, or\n  parsed body object.\n\n### .expect(field, value[, fn])\n\n  Assert header `field` `value` with a string or regular expression.\n\n### .end(fn)\n\n  Perform the request and invoke `fn(err, res)`.\n\n## Notes\n\n  Inspired by [api-easy](https://github.com/flatiron/api-easy) minus vows coupling.\n\n## License\n\n  MIT\n",
  "readmeFilename": "Readme.md",
  "_id": "supertest@0.7.1",
  "_from": "supertest@latest"
}
